// Generated by CoffeeScript 1.6.3
(function() {
  var forceChart;

  forceChart = function($compile, NodeEmitter, CollapsibleTreeLoader, FlattenVotingTree, AnimatingExperiments) {
    return {
      restrict: "EA",
      replace: true,
      scope: {
        options: '=',
        hovered: '&hovered'
      },
      link: function(scope, element, attrs) {
        var forceHeight, forceWidth, fvID, links, nodes, root, update;
        root = [];
        nodes = [];
        links = [];
        fvID = "_fv" + scope.options.initialID++;
        forceWidth = scope.options.width || angular.element(window)[0].innerWidth;
        forceHeight = scope.options.height || angular.element(window)[0].innerHeight * .7;
        scope._tick = function() {
          scope.link.attr({
            x1: function(d) {
              return d.source.x;
            },
            y1: function(d) {
              return d.source.y;
            },
            x2: function(d) {
              return d.target.x;
            },
            y2: function(d) {
              return d.target.y;
            }
          });
          return scope.node.attr({
            transform: function(d) {
              return "translate(" + d.x + "," + d.y + ")";
            }
          }).exit().attr({
            cx: function(d) {
              return d.x;
            },
            cy: function(d) {
              return d.y;
            }
          });
        };
        scope._setSelectionRadius = function(selection) {
          return selection.attr("r", function(d) {
            return scope.options.radiusMeasure || 7;
          });
        };
        scope._colorNode = function(d) {
          if (d.isDemo) {
            return "#82b446";
          } else {
            return "steelblue";
          }
        };
        scope.collapseClick = function(d) {
          if (!d3.event.defaultPrevented) {
            d.hidden = !d.hidden;
            FlattenVotingTree(scope, root);
            return update();
          }
        };
        window.onresize = function() {
          if (!scope.options.width) {
            forceWidth = angular.element(window)[0].innerWidth;
          }
          if (!scope.options.height) {
            forceHeight = angular.element(window)[0].innerHeight;
          }
          scope.force.size([forceWidth, forceHeight]);
          scope.visSvg.selectAll('.node').remove();
          if (nodes.length > 0) {
            return scope.render();
          }
        };
        scope.visSvg = d3.select(element[0]).append("svg").attr({
          width: forceWidth,
          height: forceHeight
        });
        scope.visSvg.append("clipPath").attr("id", "clip").append("circle").attr({
          cx: 0,
          cy: 0,
          r: 15
        });
        scope.force = d3.layout.force().size([forceWidth, forceHeight]).linkDistance(scope.options.force.linkDistance).charge(scope.options.force.charge).linkStrength(.35).friction(.85).theta(.9).gravity(.06).on('tick', scope._tick);
        CollapsibleTreeLoader().then(function(json) {
          root = json;
          FlattenVotingTree(scope, root);
          return scope.$watch('options.currentNode', function() {
            return update();
          });
        });
        update = function() {
          NodeEmitter(scope);
          if (scope.nodesAndLinks) {
            if (scope.nodesAndLinks.nodes) {
              nodes = scope.nodesAndLinks.nodes;
            }
            if (scope.nodesAndLinks.links) {
              links = scope.nodesAndLinks.links;
            }
            if (scope.nodesAndLinks.nodes.length > 0) {
              return scope.render();
            }
          }
        };
        console.log("Initialized nodesAndLinks: ", scope.flattenedNodesAndLinks);
        scope.link = scope.visSvg.selectAll("line.link");
        return scope.render = function() {
          var enterLinks, enterNodes;
          if (scope.options.sliderReset) {
            scope.visSvg.selectAll('.node').remove();
            scope.options.sliderReset = false;
          }
          if (!nodes || nodes.length < 1) {
            console.log("No nodes present.");
            return;
          }
          scope.force.nodes(nodes).links(links).start();
          scope.node = scope.visSvg.selectAll("g.node").data(nodes, function(d) {
            return d.id;
          }).attr({
            "transform": function(d) {
              return "translate(" + d.x + "," + d.y + ")";
            }
          });
          if (scope.options.animateExit) {
            scope.node.each(function(d) {
              return delete d[fvID].isExitting;
            }).interrupt().transition().duration(scope.options.animateExit.msToFade / 2).style(scope.options.enterAnimateStyle);
          }
          enterNodes = scope.node.enter().append('svg:g').each(function(d) {
            if (!d[fvID]) {
              d[fvID] = {};
            }
            if (scope.options.enterAtParent && d.parent && d.parent.x) {
              d.x = d.px = d.parent.x;
              d.y = d.py = d.parent.y;
            } else if (scope.options.enterCenterJitter && d.type !== 'hub' && scope.node[0][0].__data__.x) {
              d.x = d.px = scope.node[0][0].__data__.x + 2 * scope.options.enterCenterJitter * Math.random() - scope.options.enterCenterJitter;
              d.y = d.py = scope.node[0][0].__data__.y + 2 * scope.options.enterCenterJitter * Math.random() - scope.options.enterCenterJitter;
            } else if (d.type === 'hub') {
              d.x = d.px = 50;
              d.y = d.py = 50;
            } else {
              d.x = d.px = forceWidth / 2;
              d.y = d.py = forceHeight / 2;
            }
            return delete d[fvID].isExitting;
          }).attr({
            id: function(d) {
              return d.id;
            },
            "class": 'node'
          }).call(scope._setSelectionRadius).call(scope.force.drag).filter(function(d) {
            return !d.isDemo;
          }).on({
            mouseover: function(d) {
              return scope.hovered({
                args: d
              });
            },
            mouseleave: function() {
              return scope.hovered({
                args: 'leave'
              });
            }
          });
          enterNodes.filter(function(d) {
            return d.type === 'hub';
          }).append('circle').attr({
            "class": 'hub'
          }).style({
            fill: 'DarkGray'
          }).on({
            click: scope.collapseClick
          });
          scope.node.filter(function(d) {
            return d.type === 'hub';
          }).selectAll('circle').attr({
            r: function(d) {
              d.size = nodes.length;
              return d.size * .8 + 15;
            }
          });
          enterNodes.filter(function(d) {
            return d.type === 'hub';
          }).append("text").attr({
            "class": 'hub label',
            dy: .5 + 'em'
          }).text(function(d) {
            return d.name;
          }).on({
            click: scope.collapseClick
          });
          scope.node.filter(function(d) {
            return d.type === 'hub';
          }).selectAll('text').style({
            'font-size': function(d) {
              return d.size * .4 + 5 + 'px';
            },
            color: 'black'
          });
          enterNodes.filter(function(d) {
            return d.type === 'topic';
          }).append('circle').attr({
            "class": 'topic'
          }).style({
            fill: 'Chocolate'
          }).on({
            click: scope.collapseClick
          });
          scope.node.filter(function(d) {
            return d.type === 'topic';
          }).selectAll('circle').attr({
            r: function(d) {
              var pLks, vLks;
              pLks = links.filter(function(l) {
                return l.source.id === d.id;
              });
              d.size = pLks.length;
              vLks = [];
              pLks.forEach(function(pl) {
                return vLks = links.filter(function(l) {
                  return l.source.id === pl.target.id;
                });
              });
              d.size = (d.size + vLks.length) / 2 + 15;
              return d.size;
            }
          });
          enterNodes.filter(function(d) {
            return d.type === 'topic';
          }).append("text").attr({
            "class": 'topic label',
            dy: .35 + 'em'
          }).text(function(d) {
            return d.name;
          }).on({
            click: scope.collapseClick
          });
          scope.node.filter(function(d) {
            return d.type === 'topic';
          }).selectAll('text').style({
            'font-size': function(d) {
              return Math.sqrt(d.size) * 2 + 'px';
            }
          });
          enterNodes.filter(function(d) {
            return d.type === 'proposal';
          }).append('circle').attr({
            "class": 'proposal'
          }).style({
            fill: scope._colorNode
          }).on({
            click: scope.collapseClick
          });
          scope.node.filter(function(d) {
            return d.type === 'proposal';
          }).selectAll('circle').attr({
            r: function(d) {
              var pLks;
              pLks = links.filter(function(l) {
                return l.source.id === d.id;
              });
              d.size = pLks.length * 3 + 10;
              return d.size;
            }
          });
          enterNodes.filter(function(d) {
            return d.type === 'proposal';
          }).append("text").text(function(d) {
            return d.name;
          }).attr({
            "class": 'proposal label',
            dy: .35 + 'em'
          }).on({
            click: scope.collapseClick
          });
          scope.node.filter(function(d) {
            return d.type === 'proposal';
          }).selectAll('text').style({
            'font-size': function(d) {
              return Math.sqrt(d.size) * 2 + 'px';
            }
          });
          enterNodes.filter(function(d) {
            return d.type === 'voter';
          }).append('image').attr({
            'xlink:href': function(d) {
              return 'http://graph.facebook.com/' + d.name + '/picture?';
            },
            x: -20,
            y: -20,
            width: 40,
            height: 40
          }).style({
            'clip-path': 'url(#clip)'
          });
          enterNodes.filter(function(d) {
            return d.type === 'voter';
          }).append('circle').attr({
            "class": 'voter-ring',
            r: 15
          }).style({
            stroke: 'DarkOliveGreen ',
            'stroke-width': '.75',
            fill: 'none'
          });
          scope.link = scope.link.data(links, function(d) {
            return d.target.id;
          });
          enterLinks = scope.link.enter().insert("svg:line", ".node").attr({
            "class": 'link',
            x1: function(d) {
              return d.source.x;
            },
            y1: function(d) {
              return d.source.y;
            },
            x2: function(d) {
              return d.source.x;
            },
            y2: function(d) {
              return d.source.x;
            }
          });
          AnimatingExperiments(scope, enterNodes, scope.node, enterLinks, scope.link);
          if (!scope.options.animateExit) {
            console.log('no animate exit: ');
            scope.node.exit().remove();
          } else {

          }
          scope.node.exit().filter(function(d) {
            return !d[fvID].isExitting;
          }).each(function(d) {
            d[fvID].isExitting = true;
            return nodes.push(d);
          }).interrupt().transition().duration(scope.options.animateExit.msToFade).style(scope.options.exitAnimateStyle).each('end', function(d) {
            return delete d[fvID].isExitting;
          }).remove();
          scope.link.exit().remove();
          return scope.force.nodes(nodes).links(links).start();
        };
      }
    };
  };

  App.Directives.directive('forceChart', forceChart);

}).call(this);
